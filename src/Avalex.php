<?php

/**
 * avalex
 *
 * Integrate resources generated by avalex.de into any Kirby project. In order
 * to use this plugin, a valid avalex.de subscription is mandatory!
 *
 * See https://avalex.de/ for details.
 *
 * Requires avalex API Version >= 3.0
 *
 * @package Avalex\Avalex
 */

namespace Avalex\Avalex;

use Kirby\Cache\Cache;
use Kirby\Exception\InvalidArgumentException;
use Kirby\Filesystem\F;
use Kirby\Http\Remote;
use Kirby\Toolkit\A;
use Kirby\Toolkit\Date;
use Kirby\Toolkit\Str;

class Avalex {
    /**
     * Available resources (depending on the type of subscription!)
     */
    public const RESOURCE_DISCLAIMER = 'disclaimer';
    public const RESOURCE_IMPRINT = 'imprint';
    public const RESOURCE_CONDITIONS = 'conditions';
    public const RESOURCE_REVOCATION = 'revocation';

    /**
     * @var int
     */
    static private $max_age = 360; // minutes = 6 hours

    /**
     * @var string
     */
    static private $avx_version = '3.0.0';

    /**
     * @var string
     */
    private $apiurl = '';

    /**
     * @var array
     */
    private $resource_paths = [];

    /**
     * @var string
     */
    private $domain = '';

    /**
     * @var string
     */
    private $apikey = '';

    /**
     * @var string
     */
    private $language = '';

    /**
     * Avalex constructor
     *
     */
    public function __construct() {
        // use current domain if not set
        $this->domain = $this->option('domain', \Kirby\Http\Uri::current()->domain());
        $this->apikey = $this->option('apikey');
        $this->language = strval(kirby()->language() ?? $this->option('language', 'de'));
        $this->apiurl = $this->option('apiurl', 'https://avalex.de');
        $this->resource_paths = $this->option('resource-paths', [
            static::RESOURCE_DISCLAIMER => 'avx-datenschutzerklaerung',
            static::RESOURCE_IMPRINT    => 'avx-impressum',
            static::RESOURCE_CONDITIONS => 'avx-bedingungen',
            static::RESOURCE_REVOCATION => 'avx-widerruf',
        ]);
    }

    /**
     * Return the given resource's content
     *
     * @param string $name
     * @param array|scalar|null $options
     * @return string
     * @throws InvalidArgumentException|AvalexException
     */
    public function resource(string $name, mixed $options = null): string {
        if (empty($name)) {
            $this->log("Resource name must not be empty! Available resources: " . implode(', ', $this->resources()));
            return '';
        }

        if (!$this->active()) {
            $this->log("Plugin is inactive, option 'active' must be set to true!");
            return '';
        }

        if (!$this->verifyResource($name)) {
            // resource invalid
            $this->log("Unknown resource '{$name}'! Available resources: " . implode(', ', $this->resources()));
            return '';
        }

        // fix options
        if (is_scalar($options)) {
            $options = [
                'force_update' => (bool) $options,
            ];
        } elseif (!is_array($options)) {
            $options = [];
        }

        $force_update = $options['force_update'] ?? false;

        // override settings
        if ($domain = strval($options['domain'] ?? '')) {
            $this->domain = $domain;
        }
        if ($apikey = strval($options['apikey'] ?? '')) {
            $this->apikey = $apikey;
        }
        if ($language = strval($options['language'] ?? '')) {
            $this->language = $language;
        }

        // read cache
        $cache = $this->cache();
        if (!$cache->enabled()) {
            throw new AvalexException('Caching is required!');
        }

        $key = $this->cacheKey($name);

        if ($cache->expired($key) || $force_update) {
            try {
                // load resource
                $content = $this->load($name);

                if ($content) {
                    $data = [
                        'domain'   => $this->domain,
                        'language' => $this->language,
                        'content'  => $content,
                        'pulled'   => Date::now()->format(DATE_ATOM),
                    ];

                    $cache->set($key, $data, static::$max_age);
                }

            } catch (\Exception $exc) {
                $this->logException($exc);
            }
        }

        return A::get($cache->get($key, []), 'content', '');
    }

    /**
     * Returns the disclaimer HTML
     *
     * @param array|scalar|null $options
     * @return string
     */
    public function resourceDisclaimer(mixed $options = null): string {
        return $this->resource(static::RESOURCE_DISCLAIMER, $options);
    }

    /**
     * Returns the imprint HTML
     *
     * @param array|scalar|null $options
     * @return string
     */
    public function resourceImprint(mixed $options = null): string {
        return $this->resource(static::RESOURCE_IMPRINT, $options);
    }

    /**
     * Returns the general conditions HTML
     *
     * @param array|scalar|null $options
     * @return string
     */
    public function resourceConditions(mixed $options = null): string {
        return $this->resource(static::RESOURCE_CONDITIONS, $options);
    }

    /**
     * Returns the revocation HTML
     *
     * @param array|scalar|null $options
     * @return string
     */
    public function resourceRevocation(mixed $options = null): string {
        return $this->resource(static::RESOURCE_REVOCATION, $options);
    }

    /**
     * Returns option identified by $key
     *
     * @param string $key
     * @param mixed $default
     * @return mixed
     */
    private function option(string $key, mixed $default = ''): mixed {
        return option('avalex.avalex.' . $key, $default);
    }

    /**
     * Returns true if the plugin is active (default: true)
     *
     * @return bool
     */
    private function active(): bool {
        return $this->option('active', true) === true;
    }

    /**
     * Return the cache instance
     *
     * @return AvalexCache|Cache
     * @throws InvalidArgumentException
     */
    private function cache(): AvalexCache|Cache {
        return kirby()->cache('avalex.avalex.resources');
    }

    /**
     * Creates a cache key by resource name and language
     *
     * @param string $name
     * @return string
     */
    private function cacheKey(string $name): string {
        return Str::slug(A::join([$this->domain, $name, $this->language], '-'));
    }

    /**
     * Returns the timestamp of the latest API access in given format. If
     * resource name is given the access timestamp for that particular resource
     * is returned.
     *
     * @param string $format
     * @param string $name
     * @return int|string|null
     * @throws InvalidArgumentException
     */
    public function timestampLastAccess(string $format = '', string $name = ''): int|string|null {
        $cache = $this->cache();

        if (!$cache->enabled()) {
            return null;
        }

        $timestamp = null;

        if ($name) {
            // return timestamp for resource
            $timestamp = $cache->created($this->cacheKey($name));

        } else {
            // return most recent timestamp of all resources
            foreach (array_keys($this->resource_paths) as $name) {
                $created = $cache->created($this->cacheKey($name));

                if ($created
                    && (!$timestamp || $timestamp < $created)) {
                    $timestamp = $created;
                }
            }
        }

        if ($timestamp && $format) {
            return (new Date($timestamp))->format($format);
        }

        return $timestamp === false ? null : $timestamp;
    }

    /**
     * Returns array with configured domain and API key
     *
     * @return array|null
     */
    public function credentials(): ?array {
        if ($this->domain !== '' && $this->apikey !== '') {
            return [
                'domain' => $this->domain,
                'apikey' => $this->apikey,
            ];
        }

        return null;
    }

    /**
     * Verifies configuration
     *
     * @return bool
     * @throws \Exception
     */
    private function verify(): bool {
        if (!$this->active()) {
            $this->log("Plugin is inactive, option 'active' must be set to true!");
            return false;
        }

        if (!$this->credentials()) {
            $this->log("API credentials incomplete, options 'domain' and 'apikey' required!");
            return false;
        }

        return true;
    }

    /**
     * Verifies if credentials are correct
     *
     * @return bool
     * @throws \Exception
     */
    public function verifyCredentials(): bool {
        if (!$this->verify()) {
            return false;
        }

        try {
            $response = $this->remote($this->url(static::RESOURCE_DISCLAIMER));

            return $response && $response->code() === 200;

        } catch(\Exception $exc) {
            $this->logException($exc);
        }

        return false;
    }

    /**
     * Returns URL for accessing the API
     *
     * @param string $resource
     * @return string
     */
    private function url(string $resource): string {
        $path = $this->resource_paths[$resource] ?? '';

        if ($path) {
            return $this->apiurl . '/' . ltrim($path, '/');
        }

        return '';
    }

    /**
     * Returns array with query parameters for accessing the API
     *
     * @param array $params
     * @return array
     */
    private function query(array $params = []): array {
        $query = array_merge(
            $this->credentials(),
            ['version' => static::$avx_version],
            $params,
            [
                'cms'          => 'kirby',
                'plugin_token' => 'xxnlXd6AuVWiJLhP3H82BAdj9Kmen6CL',
            ]
        );

        if ($this->language !== '') {
            $query = array_merge($query, ['lang' => $this->language]);
        }

        return $query;
    }

    /**
     * Performs API request and returns Remote instance
     *
     * @param string $url
     * @param array $options
     * @return Remote
     * @throws \Exception
     */
    private function remote(string $url, array $options = []): Remote {
        $options = array_merge(
            [
                'data' => $this->query(),
                'timeout' => 10,
            ],
            $options
        );

        return Remote::get($url, $options);
    }

    /**
     * Load the specified resource from avalex
     *
     * @param string $resource
     * @return string
     * @throws AvalexException
     */
    private function load(string $resource): string {
        if ($this->verify()) {
            $url = $this->url($resource);

            if (!$url) {
                throw new AvalexException("API Resource '{$resource}': Path unknown");
            }

            try {
                $response = $this->remote($url);

                if ($response->code() === 200) {
                    $this->log("Resource loaded: {$resource} [{$this->language}]");

                    $html = trim($response->content());

                    return $this->replaceReferences($html);

                } else {
                    $reason = match($response->code()) {
                        400 => "avalex.de said '400 Bad Request'",
                        401 => "avalex.de said '401 Unauthorized'. Please check your 'apikey' and 'domain' settings.",
                        403 => "avalex.de said '403 Forbidden'. Please check your 'apikey' and 'domain' settings.",
                        404 => "avalex.de said '404 Not found'",
                        500 => "avalex.de said '500 Internal Server Error'",
                        503 => "avalex.de said '503 Service Unavailable'",
                        default => 'Unknown reason',
                    };

                    $this->log("Resource '{$resource}' not downloaded: " . $reason);
                }

            } catch (\Exception $exc) {
                $this->logException($exc);
            }
        }

        return '';
    }

    /**
     * Replace references pointing to avalex.de in order to avoid external
     * cookies
     *
     * @param string $html
     * @return string
     * @throws \Exception
     * @deprecated 2025-06-17 ?
     */
    private function replaceReferences(string $html): string {
        if ($this->option('replace-references', true) === true) {
            $matches = Str::matchAll($html, '/src="(?<url>[^"]+)"/', PREG_SET_ORDER);

            if ($matches) {
                foreach ($matches as $match) {
                    if ($match['url'] ?? '') {
                        $response = Remote::get($match['url']);

                        if ($response->code() === 200) {
                            $type = A::get($response->headers(), 'content-type');
                            $data_url = 'data:' . $type . ';base64,'
                                . base64_encode($response->content());

                            $html = str_replace($match['url'], $data_url, $html);
                        }
                    }
                }
            }
        }

        return $html;
    }

    /**
     * Write given message to log file
     *
     * @param string|array|object $data
     * @return void
     */
    private function log($data) {
        if ($this->option('log', true) === true) {
            if (is_array($data) || is_object($data)) {
                $data = var_export($data, true);
            }

            $message = Date::now()->format('Y-m-d H:i:s.u') . ' > ' . trim($data);

            $logfile = kirby()->root('logs') . '/' . ltrim($this->option('logfile', 'avalex.log'), '/');
            F::append($logfile, $message . PHP_EOL);
        }
    }

    /**
     * Write exception to log file
     *
     * @param \Exception $exc
     * @return void
     */
    private function logException(\Exception $exc) {
        $this->log('Exception: ' . $exc->getMessage());
    }

    /**
     * @return string[]
     */
    private function resources(): array {
        return [
            static::RESOURCE_DISCLAIMER,
            static::RESOURCE_IMPRINT,
            static::RESOURCE_CONDITIONS,
            static::RESOURCE_REVOCATION,
        ];
    }

    /**
     * Check if given resource exists
     *
     * @param string $resource
     * @return bool
     */
    public function verifyResource(string $resource): bool {
        return in_array($resource, $this->resources());
    }
}
